### 过滤器和监听器
#### 一. 过滤器
1. 如果为某个Servlet设置了过滤器，那么Servlet容器将不会直接调用service方法，而是先调用Filter的doFilter方法，由此决定是否调用Servlet的service方法，实现对非法请求的拦截或请求响应的额外处理的作用。
2. 如果对一个Servlet设置了多个过滤器，那么当针对该Servlet的访问请求到达时，Servlet容器将会把这多个Filter组成一个过滤器链，链中各个Filter的拦截顺序和他们在web.xml文件中的的映射顺序一致，上一个Filter的doFilter方法调用FilterChain.doFilter来激活下一个Filter的doFilter方法，最后一个Filter中的doFilter方法中调用的FilterChain.doFilter将激活目标Servlet的service方法。只要Filter链中任意一个Filter没有调用FilterChain.doFilter方法，目标Servlet的service方法就不会执行。
3. Filter接口 
    * 过滤器需实现Filter接口  
    * init方法和FilterChain接口：Servlet容器创建Filter实例对象后立即调用init方法，并将一个包含Filter配置和运行环境信息的FilterConfig对象传递给该方法，具体使用同Servlet的init方法和ServletConfig接口。
    * doFilter方法和FilterChain接口：   
    FilterChain接口用于定义一个代表Filter链的对象应该对外提供的方法，该接口中只定义了一个doFilter方法：  
    ```java
    public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException;
    ```
    当一个Filter能够拦截的访问请求到达后，Servlet容器将调用该方法的doFilter方法，方法定义：
    ```java
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletExcetion;
    ```
    chain代表当前Filter链对象，调用chain.doFilter方法可以把请求交付给Filter链中的下一个Filter或目标Servlet处理。  
    只有Filter对象的init方法执行成功后，该Filter对象才会被加入Filter链，该Filter对象的doFilter方法才会被调用。
    * destroy方法：Servlet容器卸载Filter对象之前被调用。

    ```java
    public class MyFilter implements Filter {
        public void destroy() {
        }

        public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
            chain.doFilter(req, resp);
        }

        public void init(FilterConfig config) throws ServletException {

        }
    }
    ```
4. Filter的注册
    * web.xml    
    ```xml
    <filter>
        <!--Filter的友好名称-->
        <filter-name>MyFilter</filter-name>
        <filter-class>com.test.MyFilter</filter-class>
        <init-param>
            <param-name>one</param-name>
            <param-value>first</param-value>
        </init-param>
    </filter>
    ```
    映射Filter
    * web.xml文件中，一个`<filter-mapping>`元素用于设置一个Filter所负责拦截的资源，可以通过两种方式指定`<servlet-name>`或`<url-pattern>`，只能二选一，且`<url-pattern>`中的路径映射规则同Servlet。
    * Servlet容器调用一个资源有四种方式  
        * 通过正常的请求访问
        * 通过RequestDispatcher.include调用
        * 通过RequestDispatcher.forward调用
        * 作为错误响应资源调用   
    这也决定了Filter拦截的请求的种类也有四种，即`<filter-mapping>`元素中的`<dispatcher>`的值，与上面四种相对应的是：`REQUEST` `INCLUDE` `FORWARD` `ERROR`，如果没有设置此节点的值，则默认只对`REQUEST`方式的请求做拦截。
    ```xml
    <filter-mapping>
        <filter-name>MyFilter</filter-name>
        <servlet-name>TestServlet</servlet-name>
        <dispatcher>INCLUDE</dispatcher>
        <dispatcher>ERROR</dispatcher>
    </filter-mapping>
    ```
    ```xml
    <filter-mapping>
        <filter-name>MyFilter</filter-name>
        <url-pattern>/test</url-pattern>
        <dispatcher>INCLUDE</dispatcher>
        <dispatcher>ERROR</dispatcher>
    </filter-mapping>
    ```
    在同一个web.xml文件中可以对同一个Filter设置多个映射。
    如果在一个Filter链中多次出现了同一个FIlter程序，这个Filter程序的拦截处理过程将被执行多次。

    * 基于注解的Filter注册
    ```java
    @WebFilter(filterName = "myFilter", servletNames = "testServlet",
        initParams = {@WebInitParam(name = "password", value = "123456"),
                @WebInitParam(name = "userName", value = "tomcat")
        },
        dispatcherTypes = DispatcherType.REQUEST)
    public class MyFilter implements Filter {
        public void destroy() {
        }

        public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
            chain.doFilter(req, resp);
        }

        public void init(FilterConfig config) throws ServletException {

        }
    }
    ```
    > web.xml注册的过滤器的执行顺序由`<filter-mapping>`的顺序决定，而基于注解的过滤器的执行顺序由文件名的字典顺序决定。


