### 类加载过程
* 加载：
    * 在加载阶段，虚拟机需要完成一下3件事情：
        1. 通过一个类的全限定类名来获取定义此类的二进制字节流
        2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
        3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口
* 连接：
    * 验证
        1. 文件格式验证，保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。这个阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。
        2. 元数据验证
            * 这个类是否有父类
            * 这个类的父类是否继承了不允许被继承的类（被final修饰的类）
            * 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
            * ...
        3. 字节码验证，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
        4. 符号引用验证，最后一个阶段的验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段————解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验已下内容：
            * 符号引用中通过字符串描述的全限定名是否能找到对应的类
            * 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
            * 符号引用中的类、字段、方法的访问性是否可被当前类访问。
    * 准备，准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。“初始值”通常情况下为数据类型的零值。
    * 解析，虚拟机将常量池内的符号引用替换为直接引用的过程。
        * 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。
        * 直接引用：直接引用是可以直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。
* 初始化，在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度表达：初始化阶段是执行类构造器`<clinit>()`方法的过程。`<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并成的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。
* 使用
* 卸载
---
加载、验证、准备、初始化和卸载这5个阶段的顺序是固定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定，它在某型情况下可以再初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。这里是按部就班地“开始”，而不是按部就班地“进行”或“完成”，强调这一点是因为这些阶段通常都是互相交叉地混合式进行的，通常回在一个阶段执行的过程中调用、激活另一个阶段。