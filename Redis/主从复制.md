### Redis主从复制

##### 需要主从复制的原因：
* 保证数据高可用，因为数据在多台服务器上存储了多分，即使一台宕机了，其余的机器还可以继续处理请求
* 通过读写分离降低单个Redis节点的压力，提高整体并发性能

##### 配置
配从不配主，主节点不需要配置，只需要配置从节点
```bash
# 主节点ip port
slaveof 0.0.0.0 6379
# 主节点密码
masterauth 123456
# 从节点只读
slave-read-only yes
```
##### 复制
* 每个Redis master有一个`replication ID`，这是一个随机字符串，标记了一个给定的数据集。每个master也有一个偏移量`offset`，master将自己产生的复制流发送给slave时，发送多少个字节的数据，自身的偏移量就会增加多少，目的是当有新的操作修改自己的数据集时，它可以以此更新slave的状态。复制偏移量即使在没有一个 slave 连接到 master 时，也会自增，所以基本上每一对给定的`Replication ID, offset`都会标识一个master数据集的确切版本。   
* 当slave连接到master时，它们使用`psync`命令来发送它们记录的旧的master replication ID和它们至今为止处理的偏移量。通过这种方式，master能够仅发送slave所需要的增量部分。但是如果 master 的缓冲区中没有足够的命令积压缓冲记录，或者如果 slave 引用了不再知道的历史记录（replication ID），则会转而进行一个全量重同步：在这种情况下， slave会得到一个完整的数据集副本，从头开始。    
* 全量同步：master 开启一个后台保存进程，以便于生产一个 RDB 文件。同时它开始缓存所有从客户端接收到的新的写入命令。当后台保存完成时， master 将数据集文件传输给 slave， slave将之保存在磁盘上，然后加载文件到内存。再然后 master 会发送所有缓存的命令给 slave。    
* Redis 复制在 master 侧是非阻塞的。这意味着 master 在一个或多个 slave 进行初次同步或者是部分重同步时，可以继续处理查询请求。
* 复制在 slave 侧大部分也是非阻塞的。当 slave 进行初次同步时，它可以使用旧数据集处理查询请求，假设你在 redis.conf 中配置了让 Redis 这样做的话。否则，你可以配置如果复制流断开， Redis slave 会返回一个 error 给客户端。但是，在初次同步之后，旧数据集必须被删除，同时加载新的数据集。 slave 在这个短暂的时间窗口内（如果数据集很大，会持续较长时间），会阻塞到来的连接请求。自 Redis 4.0 开始，可以配置 Redis 使删除旧数据集的操作在另一个不同的线程中进行，但是，加载新数据集的操作依然需要在主线程中进行并且会阻塞 slave 。






