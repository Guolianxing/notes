### Redis主从复制
#### 一. 主从复制
##### 需要主从复制的原因：
* 保证数据高可用，因为数据在多台服务器上存储了多分，即使一台宕机了，其余的机器还可以继续处理请求
* 通过读写分离降低单个Redis节点的压力，提高整体并发性能

##### 配置
配从不配主，主节点不需要配置，只需要配置从节点
```bash
# 主节点ip port
slaveof 0.0.0.0 6379
# 主节点密码
masterauth 123456
# 从节点只读
slave-read-only yes
```
##### 复制
* 每个Redis master有一个`replication ID`，这是一个随机字符串，标记了一个给定的数据集。每个master也有一个偏移量`offset`，master将自己产生的复制流发送给slave时，发送多少个字节的数据，自身的偏移量就会增加多少，目的是当有新的操作修改自己的数据集时，它可以以此更新slave的状态。复制偏移量即使在没有一个 slave 连接到 master 时，也会自增，所以基本上每一对给定的`Replication ID, offset`都会标识一个master数据集的确切版本。   
* 当slave连接到master时，它们使用`psync`命令来发送它们记录的旧的master replication ID和它们至今为止处理的偏移量。通过这种方式，master能够仅发送slave所需要的增量部分。但是如果 master 的缓冲区中没有足够的命令积压缓冲记录，或者如果 slave 引用了不再知道的历史记录（replication ID），则会转而进行一个全量重同步：在这种情况下， slave会得到一个完整的数据集副本，从头开始。    
* 全量同步：master 开启一个后台保存进程，以便于生产一个 RDB 文件。同时它开始缓存所有从客户端接收到的新的写入命令。当后台保存完成时， master 将数据集文件传输给 slave， slave将之保存在磁盘上，然后加载文件到内存。再然后 master 会发送所有缓存的命令给 slave。    
* Redis 复制在 master 侧是非阻塞的。这意味着 master 在一个或多个 slave 进行初次同步或者是部分重同步时，可以继续处理查询请求。
* 复制在 slave 侧大部分也是非阻塞的。当 slave 进行初次同步时，它可以使用旧数据集处理查询请求，假设你在 redis.conf 中配置了让 Redis 这样做的话。否则，你可以配置如果复制流断开， Redis slave 会返回一个 error 给客户端。但是，在初次同步之后，旧数据集必须被删除，同时加载新的数据集。 slave 在这个短暂的时间窗口内（如果数据集很大，会持续较长时间），会阻塞到来的连接请求。自 Redis 4.0 开始，可以配置 Redis 使删除旧数据集的操作在另一个不同的线程中进行，但是，加载新数据集的操作依然需要在主线程中进行并且会阻塞 slave 。

#### 二. Sentinel
主从复制虽然能提高整体性能，但是主节点出现故障后需要人工进行故障迁移，Sentinel 可以实现自动故障迁移    
Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：
* 监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常
* 提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。
* 自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。 

当一个Sentinel发现一个主服务器失效后，会将此服务器标记为`主观下线`，只有在足够数量的Sentinel都将一个服务器标记为主观下线之后， 服务器才会被标记为客观下线（objectively down， 简称 ODOWN ）， 这时自动故障迁移才会执行。   
客观下线条件只适用于主服务器： 对于任何其他类型的 Redis 实例， Sentinel 在将它们判断为下线前不需要进行协商， 所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。
#### 三. 分区
分区是将你的数据分发到不同Redis实例上的一个过程，每个Redis实例只是你所有key的一个子集。Redis分区主要有两个目的：
* 分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。
* 分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。

缺点：
* 涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例
* 同时操作多个key,则不能使用Redis事务.
* 分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集
* 当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。
* 分区时动态扩容或缩容可能非常复杂。